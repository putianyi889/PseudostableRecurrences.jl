<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · PseudostableRecurrences</title><meta name="title" content="Examples · PseudostableRecurrences"/><meta property="og:title" content="Examples · PseudostableRecurrences"/><meta property="twitter:title" content="Examples · PseudostableRecurrences"/><meta name="description" content="Documentation for PseudostableRecurrences."/><meta property="og:description" content="Documentation for PseudostableRecurrences."/><meta property="twitter:description" content="Documentation for PseudostableRecurrences."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PseudostableRecurrences</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">PseudostableRecurrences.jl</a></li><li><a class="tocitem" href="../docstrings/">Docstrings</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Linear-recursive-Sequence"><span>Linear-recursive Sequence</span></a></li><li><a class="tocitem" href="#A-definite-integral"><span>A definite integral</span></a></li><li><a class="tocitem" href="#Fractional-integral-operator"><span>Fractional integral operator</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/putianyi889/PseudostableRecurrences.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/putianyi889/PseudostableRecurrences.jl/blob/master/docs/src/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><h2 id="Linear-recursive-Sequence"><a class="docs-heading-anchor" href="#Linear-recursive-Sequence">Linear-recursive Sequence</a><a id="Linear-recursive-Sequence-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-recursive-Sequence" title="Permalink"></a></h2><p>Consider the recurrence</p><p class="math-container">\[x_1=x_2=x_3=\sqrt{2}, x_{n+3}-\frac{10}{3}x_{n+2}+3x_{n+1}-\frac{2}{3}x_n=0.\]</p><p>First, we shall recognise that the linear recursive sequence is basically a 1D stencil recurrence. The recurrence needs to be converted to an assignment first, that is, <span>$x_{n}=\frac{10}{3}x_{n-1}-3x_{n-2}+\frac{2}{3}x_{n-3}$</span>. Such a recurrence can be defined by the stencil with the coefficients</p><pre><code class="language-julia hljs">stencil = (CartesianIndex(-3), CartesianIndex(-2), CartesianIndex(-1))
coefs = (n -&gt; 2//3, n -&gt; -3, n -&gt; 10//3)</code></pre><div class="admonition is-info"><header class="admonition-header">Inhomogeneous case</header><div class="admonition-body"><p>To define a linear inhomogeneous recurrence, the coefficient associated with the zero cartesian index is used. For example, the recurrence</p><p class="math-container">\[x_{n}=\frac{10}{3}x_{n-1}-3x_{n-2}+\frac{2}{3}x_{n-3}+\frac{1}{n}\]</p><p>should be defined by</p><pre><code class="language-julia hljs">stencil = (CartesianIndex(-3), CartesianIndex(-2), CartesianIndex(-1), CartesianIndex(0))
coefs = (n -&gt; 2//3, n -&gt; -3, n -&gt; 10//3, n -&gt; 1//n)</code></pre></div></div><p>We then need to define the initial values</p><pre><code class="language-julia hljs">f_init(T) = [sqrt(T(2)), sqrt(T(2)), sqrt(T(2)), T(0)]</code></pre><p>where the place for the next step should be reserved. This is a function that can generate values based on type <code>T</code>.</p><p>Now we only need to further provide the size of the recurrence and we are ready to go.</p><pre><code class="language-julia hljs">P = StencilRecurrencePlan{Real}(stencil, coefs, f_init, (100,)) # &#39;Real&#39; specifies the domain of the entries, as opposed to &#39;Complex&#39;, etc.
stable_recurrence(P) # defaults to stable_recurrence(P, Float64)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100-element Vector{Float64}:
 1.4142135623730951
 1.4142135623730951
 1.4142135623730951
 1.4142135623730951
 1.4142135623730951
 1.4142135623730951
 1.4142135623730951
 1.4142135623730951
 1.4142135623730951
 1.4142135623730951
 ⋮
 1.4142135623730951
 1.4142135623730951
 1.4142135623730951
 1.4142135623730951
 1.4142135623730951
 1.4142135623730951
 1.414213562373095
 1.414213562373095
 1.414213562373095</code></pre><h2 id="A-definite-integral"><a class="docs-heading-anchor" href="#A-definite-integral">A definite integral</a><a id="A-definite-integral-1"></a><a class="docs-heading-anchor-permalink" href="#A-definite-integral" title="Permalink"></a></h2><p>Consider the integral</p><p class="math-container">\[I(m,n) = \int_0^\pi\left(\frac{\cos x}{1+\sin x}\right)^me^{inx}\mathrm{d}x\]</p><p>which has the recurrence</p><p class="math-container">\[I(m,n)=\begin{cases}
    2i/n,&amp; m=0, n\text{ odd}\\
    \displaystyle(-1)^{m/2}\left(\pi-4\sum_{k=1}^{m/2}\frac{(-1)^k}{2k-1}\right),&amp; m\text{ even}, n=0\\
    0,&amp; \!\!\!\begin{array}{l}
        m=0\text{ or }n=0,\\
        \text{excluding above cases}
    \end{array}\\
    \displaystyle\frac{m+n-1}{ni}I(m,n-1)+\frac{m}{n}I(m-1,n-1)+\frac{2}{n}\begin{cases}
        i,\\
        -1,
    \end{cases}&amp;\!\!\!\begin{array}{l}
        m+n\text{ odd}\\
        m+n\text{ even}.
    \end{array}
\end{cases}\]</p><p>Our goal is to obtain the numerical integrals for a range of <span>$m$</span> and <span>$n$</span>. We may use a matrix to store the results, with <code>m+1</code> and <code>n+1</code> being the row and column indices.</p><p>The problem is again a stencil recurrence, where</p><pre><code class="language-julia hljs">stencil = (CartesianIndex(-1,-1), CartesianIndex(0,-1), CartesianIndex(0,0))</code></pre><p>and</p><pre><code class="language-julia hljs">coef1(m,n) = (m-1)//(n-1)
coef2(m,n) = (m+n-3)//(n-1)//im
coef3(m,n) = 2//(n-1)*ifelse(isodd(m+n), im, -1)
coef = (coef1, coef2, coef3)</code></pre><p>Note that Julia indices starts at 1, hence the <code>m-1</code>, <code>n-1</code>, etc.. Recall that the <code>CartesianIndex(0,0)</code> and <code>coef3</code> corresponds to the inhomogeneous term <span>$\displaystyle\frac{2}{n}\begin{cases}i, &amp; m+n\text{ odd}\\ -1, &amp; m+n\text{ even}\end{cases}$</span>.</p><p>We need to initialise the first column as well.</p><pre><code class="language-julia hljs">function f_init(T, m)
    A = zeros(Complex{T},m,2)
    A[1,1] = π
    for mm in 3:2:m
        A[mm,1] = -A[mm-2,1] + 4//(mm-2)
    end
    A
end</code></pre><p>Here, <code>m</code> specifies the size of the first dimension. For an <span>$n$</span>-dimensional stencil recurrence, each slice has <span>$n-1$</span> dimensions, so the initialization function has to take <span>$n-1$</span> size arguments.</p><div class="admonition is-info"><header class="admonition-header">Initialising the first row</header><div class="admonition-body"><p><code>PseudostableRecurrences.jl</code> doesn&#39;t support initialising the first row in the backend. However, if a stencil exceeds the boundary, the external entries will be ignored. This allows one to modify the coefficients to achieve the initialization of the first row. In this example, the recurrence happens to initialise the first row correctly, so there is no need to modify it.</p></div></div><p>Then we are ready to run the recurrence.</p><pre><code class="language-julia hljs">P = StencilRecurrencePlan{Complex}(stencil, coef, f_init, (101,101), (1,2))
ret = hcat(stable_recurrence(P)...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">101×101 Matrix{ComplexF64}:
   3.14159+0.0im        0.0+2.0im          …  3.68182e-91+0.0im
       0.0+0.0im    1.14159+0.0im                     0.0+0.019998im
  0.858407-0.0im        0.0+0.283185im          0.0003998+0.0im
       0.0+0.0im   0.575222+0.0im                     0.0+0.019982im
  0.474926+0.0im        0.0+0.100296im        0.000798643+0.0im
       0.0+0.0im    0.37463+0.0im          …          0.0+0.0199501im
  0.325074-0.0im        0.0+0.0495559im        0.00119558+0.0im
       0.0+0.0im   0.275518+0.0im                     0.0+0.0199025im
  0.246355+0.0im        0.0+0.0291635im        0.00158968+0.0im
       0.0+0.0im   0.217191+0.0im                     0.0+0.0198394im
          ⋮                                ⋱             ⋮
 0.0217366+0.0im        0.0+0.000236156im      0.00996587+0.0im
       0.0+0.0im  0.0215004+0.0im                     0.0+0.0107245im
 0.0212742-0.0im        0.0+0.000226219im      0.00998141+0.0im
       0.0+0.0im   0.021048+0.0im          …          0.0+0.0105125im
 0.0208311+0.0im        0.0+0.000216896im      0.00999219+0.0im
       0.0+0.0im  0.0206142+0.0im                     0.0+0.0103045im
  0.020406-0.0im        0.0+0.000208138im      0.00999847+0.0im
       0.0+0.0im  0.0201979+0.0im                     0.0+0.0101005im
  0.019998+0.0im        0.0+0.0001999im    …    0.0100005+0.0im</code></pre><p>By design, <code>stable_recurrence</code> returns a vector of slices, so <code>hcat</code> is used to re-assemble the result. The last argument of <code>StencilRecurrencePlan</code> specifies the index where the recurrence starts at. By default, it will start from where the stencil doesn&#39;t go out of bound. In this example, however, we do want to apply the stencil to the first row in order to initialise it.</p><p>Now we compare the results against that from <a href="https://github.com/JuliaMath/QuadGK.jl"><code>QuadGK.jl</code></a> to verify the correctness:</p><pre><code class="language-julia hljs">maximum(abs, ret[92:end, 92:end] - [quadgk(x-&gt;(cos(x)/(1+sin(x)))^m*exp(im*n*x), 0, π)[1] for m in 91:100, n in 91:100])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0048920100568746e-15</code></pre><div class="admonition is-info"><header class="admonition-header">Performance</header><div class="admonition-body"><p>The recurrence is faster than generic numerical integration when the intermediate results are useful. In this example, when <code>m</code> is small and <code>n</code> is large, the function is oscillatory which <code>QuadGK.jl</code> has difficulty to handle:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime quadgk(x-&gt;(cos(x)/(1+sin(x)))^100*exp(im*100*x), 0, π);</code><code class="nohighlight hljs ansi" style="display:block;">  19.947 μs (3 allocations: 2.19 KiB)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime quadgk(x-&gt;(cos(x)/(1+sin(x)))^2*exp(im*100*x), 0, π);</code><code class="nohighlight hljs ansi" style="display:block;">  118.521 μs (4 allocations: 9.06 KiB)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime quadgk(x-&gt;exp(im*100*x), 0, π);</code><code class="nohighlight hljs ansi" style="display:block;">  264.552 ms (13 allocations: 23.76 MiB)</code></pre><p>This is why we don&#39;t compare the whole matrix.</p></div></div><h2 id="Fractional-integral-operator"><a class="docs-heading-anchor" href="#Fractional-integral-operator">Fractional integral operator</a><a id="Fractional-integral-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Fractional-integral-operator" title="Permalink"></a></h2><blockquote><p>Reference</p></blockquote><blockquote><p>Pu, Tianyi, and Marco Fasondini. &quot;The numerical solution of fractional integral equations via orthogonal polynomials in fractional powers.&quot; Advances in Computational Mathematics 49, no. 1 (2023): 7.</p></blockquote><p>As a preparation, we load some functions for operators:</p><pre><code class="language-julia hljs">include(&quot;../../test/fractional_integral_operator.jl&quot;)</code></pre><p>Suppose we know a banded integral operator <span>$L$</span>:</p><pre><code class="language-julia hljs"># 0,0,0,2 are parameters of the object space. See the reference for details.
N = 100 # truncation size
L = OpI(0,0,0,2,N)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100×100 BandedMatrix{Float64} with bandwidths (2, 2):
 0.666667  0.0       -0.133333     ⋅         …    ⋅            ⋅ 
 1.0       0.2       -0.2        -0.0857143       ⋅            ⋅ 
 0.333333  0.333333   0.047619   -0.142857        ⋅            ⋅ 
  ⋅        0.133333   0.2         0.0222222       ⋅            ⋅ 
  ⋅         ⋅         0.0857143   0.142857        ⋅            ⋅ 
  ⋅         ⋅          ⋅          0.0634921  …    ⋅            ⋅ 
  ⋅         ⋅          ⋅           ⋅              ⋅            ⋅ 
  ⋅         ⋅          ⋅           ⋅              ⋅            ⋅ 
  ⋅         ⋅          ⋅           ⋅              ⋅            ⋅ 
  ⋅         ⋅          ⋅           ⋅              ⋅            ⋅ 
 ⋮                                           ⋱               
  ⋅         ⋅          ⋅           ⋅              ⋅            ⋅ 
  ⋅         ⋅          ⋅           ⋅              ⋅            ⋅ 
  ⋅         ⋅          ⋅           ⋅              ⋅            ⋅ 
  ⋅         ⋅          ⋅           ⋅              ⋅            ⋅ 
  ⋅         ⋅          ⋅           ⋅         …    ⋅            ⋅ 
  ⋅         ⋅          ⋅           ⋅            -0.00255109    ⋅ 
  ⋅         ⋅          ⋅           ⋅            -0.00507614  -0.00252532
  ⋅         ⋅          ⋅           ⋅             2.57699e-5  -0.00502513
  ⋅         ⋅          ⋅           ⋅             0.00507614   2.52544e-5</code></pre><p>and we want to obtain <span>$\sqrt{L}$</span> which is upper Hessenberg. We know how to compute each entry of <span>$\sqrt{L}$</span>:</p><pre><code class="language-julia hljs"># 0.5 is the order for sqrt.
# the last argument is truncation size.
sqrtL = OpI11(0,0,0,2,0.5,5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7×6 Matrix{Float64}:
 0.797885  0.0376582  -0.112975   -0.00353121  -0.011373   -0.00177763
 0.797885  0.45543    -0.0896734  -0.120037    -0.0117627  -0.0181185
 0.0       0.417771    0.342455   -0.100871    -0.109833   -0.0154641
 0.0       0.0         0.319154    0.284202    -0.0981327  -0.10092
 0.0       0.0         0.0         0.268567     0.247721   -0.0931577
 0.0       0.0         0.0         0.0          0.23641     0.222272
 0.0       0.0         0.0         0.0          0.0         0.213633</code></pre><p>but it&#39;s very expensive. Fortunately, we have the banded Sylvester equation <span>$\sqrt{L}L = L\sqrt{L}$</span> which is basically a stencil recurrence, so we can just compute the first few entries and use recurrence to get the rest. Further, <code>PseudostableRecurrences.jl</code> has <code>BandedSylvesterRecurrence</code> implemented, so we have a shortcut.</p><p>The <code>BandedSylvesterRecurrence</code> solves the equation <span>$AX+XB+C=O$</span> through recurrence. In this example, <span>$A=L$</span>, <span>$B=-L$</span>, <span>$C=O$</span> and <span>$X=\sqrt{L}$</span>.</p><pre><code class="language-julia hljs">A(T) = OpI(T(0), T(0), T(0), T(2), N+4) # computes a big enough truncation of L
B(T) = -A(T)
C(T) = Zeros{T}(∞,∞)</code></pre><p>We then set the initial condition. The stencil is a 5x5 cross so we need 5 columns for the buffer.</p><pre><code class="language-julia hljs">function init(T, N) # N is the height
    ret = zeros(T, N, 5)
    ret[1:3, 1:2] = OpI11(T(0), T(0), T(0), T(2), T(0.5), 1) # just need the very first results
    ret
end</code></pre><p>Now we are ready to go.</p><pre><code class="language-julia hljs">P = BandedSylvesterRecurrencePlan(A, B, C, init, (N+2,N+1), (2, 2))
sqrtL = hcat(stable_recurrence(P)...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">102×101 Matrix{Float64}:
 0.797885  0.0376582  -0.112975   -0.00353121  …  -5.56587e-7  -5.71584e-7
 0.797885  0.45543    -0.0896734  -0.120037       -1.76799e-6  -1.62137e-6
 0.0       0.417771    0.342455   -0.100871       -2.78554e-6  -2.8604e-6
 0.0       0.0         0.319154    0.284202       -4.1314e-6   -3.78899e-6
 0.0       0.0         0.0         0.268567       -5.02495e-6  -5.15916e-6
 0.0       0.0         0.0         0.0         …  -6.50949e-6  -5.97056e-6
 0.0       0.0         0.0         0.0            -7.28327e-6  -7.47594e-6
 0.0       0.0         0.0         0.0            -8.91084e-6  -8.1742e-6
 0.0       0.0         0.0         0.0            -9.56916e-6  -9.81899e-6
 0.0       0.0         0.0         0.0            -1.13443e-5  -1.04083e-5
 ⋮                                             ⋱                ⋮
 0.0       0.0         0.0         0.0            -0.00309099  -0.00190603
 0.0       0.0         0.0         0.0            -0.00308256  -0.00307602
 0.0       0.0         0.0         0.0         …  -0.0062166   -0.00306771
 0.0       0.0         0.0         0.0            -0.0062002   -0.0061861
 0.0       0.0         0.0         0.0            -0.0249988   -0.00616995
 0.0       0.0         0.0         0.0            -0.0249349   -0.0248748
 0.0       0.0         0.0         0.0             0.0502511   -0.0248118
 0.0       0.0         0.0         0.0         …   0.0501258    0.0499992
 0.0       0.0         0.0         0.0             0.0          0.0498758</code></pre><p>where <code>(N+2,N+1)</code> is the size of <code>sqrtL</code> and <code>(2, 2)</code> is the bandwidth of <code>B</code>.</p><p>We can test that <code>sqrtL</code> is indeed the square root of <code>L</code>:</p><pre><code class="language-julia hljs">maximum(abs, sqrtL[1:N,1:N+1]*sqrtL[1:N+1,1:N] - L)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.1102230246251565e-16</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../docstrings/">« Docstrings</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Sunday 3 March 2024 18:57">Sunday 3 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
