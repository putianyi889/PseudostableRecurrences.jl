var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Linear-recursive-Sequence","page":"Examples","title":"Linear-recursive Sequence","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Consider the recurrence","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"x_1=x_2=x_3=sqrt2 x_n+3-frac103x_n+2+3x_n+1-frac23x_n=0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, we shall recognise that the linear recursive sequence is basically a 1D stencil recurrence. The recurrence needs to be converted to an assignment first, that is, x_n=frac103x_n-1-3x_n-2+frac23x_n-3. Such a recurrence can be defined by the stencil with the coefficients","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"stencil = (CartesianIndex(-3), CartesianIndex(-2), CartesianIndex(-1))\ncoefs = (n -> 2//3, n -> -3, n -> 10//3)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Inhomogeneous case\nTo define a linear inhomogeneous recurrence, the coefficient associated with the zero cartesian index is used. For example, the recurrencex_n=frac103x_n-1-3x_n-2+frac23x_n-3+frac1nshould be defined bystencil = (CartesianIndex(-3), CartesianIndex(-2), CartesianIndex(-1), CartesianIndex(0))\ncoefs = (n -> 2//3, n -> -3, n -> 10//3, n -> 1//n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We then need to define the initial values","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"f_init(T) = [sqrt(T(2)), sqrt(T(2)), sqrt(T(2)), T(0)]\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where the place for the next step should be reserved. This is a function that can generate values based on type T.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we only need to further provide the size of the recurrence and we are ready to go.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"P = StencilRecurrencePlan{Real}(stencil, coefs, f_init, (100,)) # 'Real' specifies the domain of the entries, as opposed to 'Complex', etc.\nstable_recurrence(P) # defaults to stable_recurrence(P, Float64)","category":"page"},{"location":"examples/#A-definite-integral","page":"Examples","title":"A definite integral","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Consider the integral","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"I(mn) = int_0^pileft(fraccos x1+sin xright)^me^inxmathrmdx","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"which has the recurrence","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"I(mn)=begincases\n    2in m=0 ntext odd\n    displaystyle(-1)^m2left(pi-4sum_k=1^m2frac(-1)^k2k-1right) mtext even n=0\n    0 beginarrayl\n        m=0text or n=0\n        textexcluding above cases\n    endarray\n    displaystylefracm+n-1niI(mn-1)+fracmnI(m-1n-1)+frac2nbegincases\n        i\n        -1\n    endcasesbeginarrayl\n        m+ntext odd\n        m+ntext even\n    endarray\nendcases","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Our goal is to obtain the numerical integrals for a range of m and n. We may use a matrix to store the results, with m+1 and n+1 being the row and column indices.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The problem is again a stencil recurrence, where","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"stencil = (CartesianIndex(-1,-1), CartesianIndex(0,-1), CartesianIndex(0,0))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"coef1(m,n) = (m-1)//(n-1)\ncoef2(m,n) = (m+n-3)//(n-1)//im\ncoef3(m,n) = 2//(n-1)*ifelse(isodd(m+n), im, -1)\ncoef = (coef1, coef2, coef3)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that Julia indices starts at 1, hence the m-1, n-1, etc.. Recall that the CartesianIndex(0,0) and coef3 corresponds to the inhomogeneous term displaystylefrac2nbegincasesi  m+ntext odd -1  m+ntext evenendcases.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We need to initialise the first column as well.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function f_init(T, m)\n    A = zeros(Complex{T},m,2)\n    A[1,1] = π\n    for mm in 3:2:m\n        A[mm,1] = -A[mm-2,1] + 4//(mm-2)\n    end\n    A\nend\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here, m specifies the size of the first dimension. For an n-dimensional stencil recurrence, each slice has n-1 dimensions, so the initialization function has to take n-1 size arguments.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Initialising the first row\nPseudostableRecurrences.jl doesn't support initialising the first row in the backend. However, if a stencil exceeds the boundary, the external entries will be ignored. This allows one to modify the coefficients to achieve the initialization of the first row. In this example, the recurrence happens to initialise the first row correctly, so there is no need to modify it.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then we are ready to run the recurrence.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"P = StencilRecurrencePlan{Complex}(stencil, coef, f_init, (101,101), (1,2))\nret = hcat(stable_recurrence(P)...)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"By design, stable_recurrence returns a vector of slices, so hcat is used to re-assemble the result. The last argument of StencilRecurrencePlan specifies the index where the recurrence starts at. By default, it will start from where the stencil doesn't go out of bound. In this example, however, we do want to apply the stencil to the first row in order to initialise it.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we compare the results against that from QuadGK.jl to verify the correctness:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"maximum(abs, ret[92:end, 92:end] - [quadgk(x->(cos(x)/(1+sin(x)))^m*exp(im*n*x), 0, π)[1] for m in 91:100, n in 91:100])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Performance\nThe recurrence is faster than generic numerical integration when the intermediate results are useful. In this example, when m is small and n is large, the function is oscillatory which QuadGK.jl has difficulty to handle:@btime quadgk(x->(cos(x)/(1+sin(x)))^100*exp(im*100*x), 0, π);\n@btime quadgk(x->(cos(x)/(1+sin(x)))^2*exp(im*100*x), 0, π);\n@btime quadgk(x->exp(im*100*x), 0, π);This is why we don't compare the whole matrix.","category":"page"},{"location":"examples/#Fractional-integral-operator","page":"Examples","title":"Fractional integral operator","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Reference","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pu, Tianyi, and Marco Fasondini. \"The numerical solution of fractional integral equations via orthogonal polynomials in fractional powers.\" Advances in Computational Mathematics 49, no. 1 (2023): 7.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As a preparation, we load some functions for operators:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"include(\"../../test/fractional_integral_operator.jl\")\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Suppose we know a banded integral operator L:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# 0,0,0,2 are parameters of the object space. See the reference for details.\nN = 100 # truncation size\nL = OpI(0,0,0,2,N) ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and we want to obtain sqrtL which is upper Hessenberg. We know how to compute each entry of sqrtL:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# 0.5 is the order for sqrt.\n# the last argument is truncation size.\nsqrtL = OpI11(0,0,0,2,0.5,5)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"but it's very expensive. Fortunately, we have the banded Sylvester equation sqrtLL = LsqrtL which is basically a stencil recurrence, so we can just compute the first few entries and use recurrence to get the rest. Further, PseudostableRecurrences.jl has BandedSylvesterRecurrence implemented, so we have a shortcut.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The BandedSylvesterRecurrence solves the equation AX+XB+C=O through recurrence. In this example, A=L, B=-L, C=O and X=sqrtL.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A(T) = OpI(T(0), T(0), T(0), T(2), N+4) # computes a big enough truncation of L\nB(T) = -A(T)\nC(T) = Zeros{T}(∞,∞)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We then set the initial condition. The stencil is a 5x5 cross so we need 5 columns for the buffer.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function init(T, N) # N is the height\n    ret = zeros(T, N, 5)\n    ret[1:3, 1:2] = OpI11(T(0), T(0), T(0), T(2), T(0.5), 1) # just need the very first results\n    ret\nend\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we are ready to go.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"P = BandedSylvesterRecurrencePlan(A, B, C, init, (N+2,N+1), (2, 2))\nsqrtL = hcat(stable_recurrence(P)...)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where (N+2,N+1) is the size of sqrtL and (2, 2) is the bandwidth of B.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can test that sqrtL is indeed the square root of L:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"maximum(abs, sqrtL[1:N,1:N+1]*sqrtL[1:N+1,1:N] - L)","category":"page"},{"location":"#PseudostableRecurrences.jl","page":"PseudostableRecurrences.jl","title":"PseudostableRecurrences.jl","text":"","category":"section"},{"location":"#Introduction","page":"PseudostableRecurrences.jl","title":"Introduction","text":"","category":"section"},{"location":"","page":"PseudostableRecurrences.jl","title":"PseudostableRecurrences.jl","text":"Consider the recurrence","category":"page"},{"location":"","page":"PseudostableRecurrences.jl","title":"PseudostableRecurrences.jl","text":"x_1=x_2=x_3=sqrt2 x_n+3-frac103x_n+2+3x_n+1-frac23x_n=0","category":"page"},{"location":"","page":"PseudostableRecurrences.jl","title":"PseudostableRecurrences.jl","text":"Its eigenvalues are 2, frac13 and 1, so the solution is constant - x_n=sqrt2. However, the forward recurrence is numerically unstable since an eigenvalue is greater than 1. The following experiment confirms that.","category":"page"},{"location":"","page":"PseudostableRecurrences.jl","title":"PseudostableRecurrences.jl","text":"using Plots\nN = 100\nx = zeros(N)\nx[1] = sqrt(2)\nx[2] = sqrt(2)\nx[3] = sqrt(2)\nfor k in 1:N-3\n    x[k+3] = 10/3*x[k+2] - 3*x[k+1] + 2/3*x[k]\nend\nplot(4:N, abs.(x.-sqrt(2))[4:N], label=\"numerical error\", yaxis=:log, background_color=:transparent, foreground_color=:gray)","category":"page"},{"location":"","page":"PseudostableRecurrences.jl","title":"PseudostableRecurrences.jl","text":"The backward recurrence, on the other hand, will be dominated by the eigenvalue frac13 instead. While there may be other algorithms that are stable in this case, they often requires the asymptotic behavior of the sequence and vary across different problems.","category":"page"},{"location":"","page":"PseudostableRecurrences.jl","title":"PseudostableRecurrences.jl","text":"The idea of pseudo-stablisation is to use a high precision to achieve a given error tolerance despite the instability. The precision choice is smart such that no extra care is taken by the end user, resulting in a \"stable\" behavior. Needless to say, pseudo-stablisation only works on problems where the initial values and the recurrence coefficients can be computed to arbitrary precision.","category":"page"},{"location":"","page":"PseudostableRecurrences.jl","title":"PseudostableRecurrences.jl","text":"The current iteration of the strategy focuses on linear problems, where the end error scales linearly with the initial error which is considered as machine epsilon. To get the scaling factor, a test recurrence with random initial values is run. The random initial values ensure that the initial error is significant and the leading eigenvalue immediately takes over. The estimated scaling factor is then the ratio between the end norm of the test run and the initial norm.","category":"page"},{"location":"","page":"PseudostableRecurrences.jl","title":"PseudostableRecurrences.jl","text":"The test recurrence may sound like a performance trade-off, but since it is run under a low precision, the cost is negligible.","category":"page"},{"location":"","page":"PseudostableRecurrences.jl","title":"PseudostableRecurrences.jl","text":"For how PseudostableRecurrence.jl solves this recurrence and a few further examples, navigate to Examples.","category":"page"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/#PseudostableRecurrences.AbstractLinearRecurrence","page":"Docstrings","title":"PseudostableRecurrences.AbstractLinearRecurrence","text":"AbstractLinearRecurrence{T} <: AbstractRecurrence{T}\n\nA recurrence where the results are linear w.r.t. the initial conditions. To support pseudostablization, the following methods are needed:\n\nrdiv!(::AbstractLinearRecurrence, x::Number): divides the system by x. It is used to prevent floating point overflow.\nLinearAlgebra.norm(step!(::AbstractLinearRecurrence), Inf): computes the ∞-norm of a step. It is used to get the amplification of the system.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#PseudostableRecurrences.AbstractLinearRecurrencePlan","page":"Docstrings","title":"PseudostableRecurrences.AbstractLinearRecurrencePlan","text":"AbstractLinearRecurrencePlan <: AbstractRecurrencePlan\n\nA recurrence plan where the results are linear w.r.t. the initial conditions. Pseudostablization algorithm on linear recurrences is implemented.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#PseudostableRecurrences.AbstractRecurrence","page":"Docstrings","title":"PseudostableRecurrences.AbstractRecurrence","text":"AbstractRecurrence{T}\n\nThe abstract type where a recurrence instance runs. It needs to support the following methods:\n\nstep!(::AbstractRecurrence): step forward the recurrence. Returns nothing if the recurrence terminates, otherwise returns a view of the stepping result.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#PseudostableRecurrences.AbstractRecurrencePlan","page":"Docstrings","title":"PseudostableRecurrences.AbstractRecurrencePlan","text":"AbstractRecurrencePlan\n\nThe abstract type of recurrence plans. A recurrence plan should include all the information that can perform a recurrence with a precision. It needs to support the following methods:\n\ninit(::AbstractRecurrencePlan; T=Float64, init=:default): generates an AbstractRecurrence object where the actual recurrence runs on. Returns a vector of the view of the initial steps as well.\nT is the underlying type where the precision is implied. \ninit tells how the initial values are generated. Must support :default for the forward recurrence to run. It is also suggested to support :rand for the pseudostablization algorithm.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#PseudostableRecurrences.BandedSylvesterRecurrence","page":"Docstrings","title":"PseudostableRecurrences.BandedSylvesterRecurrence","text":"BandedSylvesterRecurrence{T, TA<:AbstractMatrix{T}, TB<:AbstractMatrix{T}, TC<:AbstractMatrix{T}, TX<:AbstractMatrix{T}} <: AbstractLinearRecurrence{slicetype(TX)}\n\nThe recurrence generated from the infinite Sylvester equation AX+XB+C=0, assuming X has infinite number of columns. The upper bandwidth of A has to be finite, the lower bandwidth of B has to be positive and finite and the lower bounding band of B can't contain zero. The recurrence is basically a cross-shaped stencil recurrence, where the width of the stencil is determined by The total bandwidth of B and the height by that of A. See also BandedSylvesterRecurrencePlan.\n\nnote: Note\nThe restriction to the bandwidths may not be optimal, but it's the boundary of our knowledge at the moment.\n\nProperties\n\nA::TA, B::TB, C::TC: the matrices A, B and C. It's recommended to use BandedMatrices.jl to boost performance. Their dimensions don't have to match. Just make sure that no BoundsError happens during the recurrence.\nbuffer::TX: the buffer that stores temp results.\nsliceind::Int: the current column index.\nlastind::Int: the last column index to be computed.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#PseudostableRecurrences.BandedSylvesterRecurrencePlan","page":"Docstrings","title":"PseudostableRecurrences.BandedSylvesterRecurrencePlan","text":"BandedSylvesterRecurrencePlan{FA<:Function, FB<:Function, FC<:Function, INIT<:Function} <: AbstractLinearRecurrencePlan\n\nSee also BandedSylvesterRecurrence.\n\nProperties\n\nfA::FA, fB::FB, fC::FC: the functions that generate A, B and C for the BandedSylvesterRecurrence. The functions should have the form f(eltype, size...).\ninit::INIT: the function that generates the first few columns of X in order to start the recurrence. It should have the form f(eltype, size...).\nsize::Dims{2}: the size of X.\nbandB::NTuple{2,Int}: the bandwidths of B. Although B can have infinite upper bandwidth, that will cause the stencil to have infinite width and hence in practice, the upper bandwidth of B is always limited by the finite width of X.\nfirstind::Int: the first column to be computed. The default value is bandB[2]+1.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#PseudostableRecurrences.StencilRecurrence","page":"Docstrings","title":"PseudostableRecurrences.StencilRecurrence","text":"StencilRecurrence{N,T,S,\n    COEF<:NTuple{S,AbstractArray{T,N}},\n    TB<:AbstractArray{T,N},}\n    (stencil, coef, buffer, slicestart, sliceend, lastind)\n\nParameters\n\nN: system dimension\nT: eltype\nS: stencil size\n\nProperties\n\nFor coef and slicesupport, tt's suggested to use lazy arrays for performance.\n\nstencil::NTuple{S, CartesianIndex{N}}: The relative index of the stencil. Can contain (0,0) (see coef)\ncoef::COEF<:NTuple{S,AbstractArray{T,N}}: The coefficient associated with each relative index. The one associated with CartesianIndex(0,0) refers to a constant added to that entry. It's suggested to use lazy arrays for performance.\nbuffer::CircularArray{T,N,TB<:AbstractArray{T,N}}: a buffer to store temp results. \nslicestart::MVector{N, Int} and sliceend::MVector{N, Int}: marks the current range of entries to be determined. Technically NTuple{N-1, Int} should work, but Julia doesn't support computed type parameters.\nlastslice::Int: marks the index of the slice where the recurrence terminates.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#PseudostableRecurrences.StencilRecurrencePlan","page":"Docstrings","title":"PseudostableRecurrences.StencilRecurrencePlan","text":"StencilRecurrencePlan{N, D, S, COEF<:NTuple{S,Function}, INIT<:Function} <: AbstractLinearRecurrencePlan\n\nParameters\n\nN: system dimension\nD: number domain, e.g. Real, Complex, etc.\nS: stencil size\n\nProperties\n\nstencil::SVector{S, CartesianIndex{N}}: The relative index of the stencil. Can contain (0,0) (see coef)\ncoef::COEF<:NTuple{S,Function}: The coefficient associated with each relative index. The one associated with CartesianIndex(0,0) refers to a constant added to that entry. The functions should be in the form f(T, I...) where I is the index of the stencil and T is the suggested return type. Coefficients should be at least as accurate as T. Exact-value types such as Irrational, Rational or Integer would do the job, and if that's not possible, BigFloat would work as well.\ninit::INIT<:Function: the function used for initial values. The functions should be in the form f(I...) or f(T, I...) where I is the size of the array, excluding the last dimension, and T is the precisiontype. For the former case, f should return exact values, i.e. Integer, Rational or Irrational.\nsize::Dims{N}: the size of the whole array.\noffset::NTuple{N,Int}: the very first index where the recurrence starts at.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#PseudostableRecurrences.ToPrecision","page":"Docstrings","title":"PseudostableRecurrences.ToPrecision","text":"ToPrecision{F}(f::F) <: Function\n\nCreate a function where the first argument specifies the returned precisiontype:     (f::ToPrecision)(T, args...) = convert_precisiontype(precisiontype(T), f.f(args...))\n\nExamples\n\njulia> f() = π\nf (generic function with 1 method)\n\njulia> f(n) = 1//n + (n-1)//n*im\nf (generic function with 2 methods)\n\njulia> g = ToPrecision(f)\n(::PseudostableRecurrences.ToPrecision{typeof(f)}) (generic function with 1 method)\n\njulia> g(Float64)\n3.141592653589793\n\njulia> g(BigFloat)\n3.141592653589793238462643383279502884197169399375105820974944592307816406286198\n\njulia> g(Float16, 7)\nFloat16(0.1428) + Float16(0.857)im\n\njulia> g(Float32, 3)\n0.33333334f0 + 0.6666667f0im\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#PseudostableRecurrences._dotu-Tuple{Any, Any}","page":"Docstrings","title":"PseudostableRecurrences._dotu","text":"_dotu(x, y) = mapreduce(*, +, x, y)\n\nNot to be confused with LinearAlgebra.BLAS.dotu. See https://github.com/JuliaLang/julia/pull/27677\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PseudostableRecurrences.method_to_precision-Tuple{Any, Any}","page":"Docstrings","title":"PseudostableRecurrences.method_to_precision","text":"method_to_precision(f, argtypes)\n\nIf hasmethod(f, argtypes), return ToPrecision(f). Otherwise return f.\n\nExamples\n\njulia> f() = π\n\njulia> Tf = methodtoprecision(BigFloat, f, Tuple{})\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PseudostableRecurrences.precision_shift-Tuple{PseudostableRecurrences.AbstractLinearRecurrencePlan}","page":"Docstrings","title":"PseudostableRecurrences.precision_shift","text":"precision_shift(P::AbstractLinearRecurrencePlan)\n\nEstimates log2 of the amplification of P by performing a full recurrence based on random initial conditions.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#PseudostableRecurrences.slicetype-Tuple{Any}","page":"Docstrings","title":"PseudostableRecurrences.slicetype","text":"slicetype(T)\n\nGet the type of a slice of T\n\nExamples\n\njulia> using PseudostableRecurrences: slicetype\n\njulia> slicetype(Matrix{Float64})\nVector{Float64} (alias for Array{Float64, 1})\n\njulia> slicetype(UnitRange{Int})\nInt64\n\njulia> slicetype(BitArray{3})\nBitMatrix (alias for BitArray{2})\n\n\n\n\n\n","category":"method"}]
}
